package Glib::IO;

=encoding utf8

=head1 NAME

Glib::IO - Perl bindings to the GIO library

=head1 SYNOPSIS

  XXX

=head1 ABSTRACT

XXX

=head1 DESCRIPTION

XXX

=cut

use strict;
use warnings;
use Glib::Object::Introspection;
use Encode;

=head2 Wrapped libraries

XXX

=cut

my $GIO_BASENAME = 'Gio';
my $GIO_VERSION = '2.0';
my $GIO_PACKAGE = 'Glib::IO';

# customization

# measure_disk_usage doesn't work
my @_CLASS_STATIC_METHODS = qw/
	Glib::IO::File::new_for_path
	Glib::IO::File::new_for_uri
	Glib::IO::File::new_for_commandline_arg
	Glib::IO::File::new_for_commandline_arg_and_cwd
	Glib::IO::File::new_tmp
	Glib::IO::File::parse_name
/;

sub import {
  Glib::Object::Introspection->setup(
    basename => $GIO_BASENAME,
    version => $GIO_VERSION,
    package => $GIO_PACKAGE,

    class_static_methods =>\@_CLASS_STATIC_METHODS);
}

=head2 Customizations and overrides

In order to make things more Perlish or to make porting from Gtk2 to Gtk3 easier, Gtk3 customizes the API generated by Glib::Object::Introspection in a few spots:XXX

=head3 Class-Static Methods

The following functions are treated as class-static methods:

=over

=item * Glib::IO::File::new_for_path

=item *	Glib::IO::File::new_for_uri

=item *	Glib::IO::File::new_for_commandline_arg

=item *	Glib::IO::File::new_for_commandline_arg_and_cwd

=item *	Glib::IO::File::new_tmp

=item *	Glib::IO::File::parse_name

=back

=head3 Reading and writing files with the Gio API

GIO reads and writes files in raw bytes format. We have to convert these data so that Perl can understand them better. Therefore we convert the bytes (= pure digits) to a bytestring without encoding The user then needs to decide what to do with it und possibly decode or encode the string in the UTF-8 Format by himself with my $content_utf8 = decode('utf-8', $content); or my $content_bytesrting = encode('utf-8', $content_utf8);

This modification is implemented for the following methods:
  
=over

=item * Glib::IO::File::load_contents

=item * Glib::IO::File::load_contents_finish

=item * Glib::IO::File::load_partial_contents_finish

=item * Glib::IO::File::replace_contents

=item * Glib::IO::File::replace_contents_async

=back

=cut

sub Glib::IO::File::load_contents {
	my ($gfile, $gcancellable) = @_;
	my ($success, $raw_content, $etag_out) = Glib::Object::Introspection->invoke (
		'Gio','File','load_contents',$gfile,$gcancellable
		);
	# the problem is, that GIO reads and writes files in raw bytes format.
	# We have to convert these data so that Perl can understand them.
	# Therefore we convert the bytes (= pure digits) to a bytestring without encoding
	# The user then needs to decide what to do with it und possibly decode the string
	# in the UTF-8 Format by himself
	my $content = pack "C*", @{$raw_content};

	return ($success,$content, $etag_out);
}

# The async modes should need the same hack, but TO-DO = TESTING!!!
sub Glib::IO::File::load_contents_finish {
	my ($gfile, $GAsyncResult) = @_;
	my ($success, $raw_content, $etag_out) = Glib::Object::Introspection->invoke (
		'Gio','File','load_contents',$gfile,$GAsyncResult
		);
	# the problem is, that GIO reads and writes files in raw bytes format.
	# We have to convert these data so that Perl can understand them.
	# Therefore we convert the bytes (= pure digits) to a bytestring without encoding
	# The user then needs to decide what to do with it und possibly decode the string
	# in the UTF-8 Format by himself
	my $content = pack "C*", @{$raw_content};

	return ($success,$content, $etag_out);
}

sub Glib::IO::File::load_partial_contents_finish {
	my ($gfile, $GAsyncResult) = @_;
	my ($success, $raw_content, $etag_out) = Glib::Object::Introspection->invoke (
		'Gio','File','load_contents',$gfile,$GAsyncResult
		);
	# the problem is, that GIO reads and writes files in raw bytes format.
	# We have to convert these data so that Perl can understand them.
	# Therefore we convert the bytes (= pure digits) to a bytestring without encoding
	# The user then needs to decide what to do with it und possibly decode the string
	# in the UTF-8 Format by himself
	my $content = pack "C*", @{$raw_content};

	return ($success,$content, $etag_out);
}

sub Glib::IO::File::replace_contents {
	my ($gfile, $content, $etag, $make_backup, $flags, $GCancellable) = @_;
	# the problem is, that GIO reads and writes files in raw bytes format,
	# which means everything is passed on without any encoding/decoding.
	# Therefore we have to convert the perlish content into an array ref containing
	# the raw bytes
	my @contents = unpack "C*", $content;
	return Glib::Object::Introspection->invoke (
		'Gio','File','replace_contents', $gfile, \@contents, $etag, $make_backup, $flags, $GCancellable
		);
}

# The async modes should need the same hack, but TO-DO = TESTING!!!
sub Glib::IO::File::replace_contents_async {
	my ($gfile, $content, $etag, $make_backup, $flags, $GCancellable, $GAsyncReadyCallback, $userdata) = @_;
	# the problem is, that GIO reads and writes files in raw bytes format,
	# which means everything is passed on without any encoding/decoding.
	# Therefore we have to convert the perlish content into an array ref containing
	# the raw bytes
	my @contents = unpack "C*", $content;
	return Glib::Object::Introspection->invoke (
		'Gio','File','replace_contents', $gfile, \@contents, $etag, $make_backup, $flags, $GCancellable, $GAsyncReadyCallback, $userdata
		);
}

# TO DO Glib::IO::File::replace_contents_bytes_async


1;

__END__

=head1 SEE ALSO

XXX

=head1 AUTHORS

=over

=item Torsten Schönfeld <kaffeetisch@gmx.de>

=back

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2010-2015 by Torsten Schönfeld <kaffeetisch@gmx.de>

This library is free software; you can redistribute it and/or modify it under
the terms of the Lesser General Public License (LGPL).  For more information,
see http://www.fsf.org/licenses/lgpl.txt

=cut
